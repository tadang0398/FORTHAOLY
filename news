<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>Happy Birthday Thao Ly - Ultimate 3D</title>
    <style>
        /* --- CSS SETUP --- */
        body { margin: 0; overflow: hidden; background-color: #050208; font-family: 'Segoe UI', sans-serif; }
        #canvas-container { position: absolute; top: 0; left: 0; width: 100vw; height: 100vh; z-index: 1; }
        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            z-index: 10; pointer-events: none;
            display: flex; flex-direction: column; align-items: center; justify-content: space-between;
            transition: opacity 0.5s ease;
        }
        .header-content { margin-top: 35px; text-align: center; pointer-events: none; transition: opacity 0.5s; }
        h1 {
            color: #ffecd2; font-size: 3.5rem; margin: 0; font-weight: 300;
            text-shadow: 0 0 25px rgba(255, 215, 100, 0.6);
            font-family: 'Cinzel', serif; letter-spacing: 5px;
        }
        .subtext { color: rgba(255, 255, 255, 0.7); margin-top: 5px; font-size: 1rem; letter-spacing: 3px; }
        .controls-wrapper {
            pointer-events: auto; position: absolute; top: 30px; right: 30px;
            display: flex; flex-direction: column; gap: 12px; align-items: flex-end;
            transition: opacity 0.5s, transform 0.5s;
        }
        .btn-glass {
            background: rgba(20, 20, 20, 0.6);
            border: 1px solid rgba(212, 175, 55, 0.4);
            color: #d4af37; padding: 10px 18px; cursor: pointer;
            text-transform: uppercase; letter-spacing: 1.5px; font-size: 11px;
            backdrop-filter: blur(5px); transition: all 0.3s;
            border-radius: 6px; display: flex; align-items: center; gap: 8px;
            text-decoration: none;
        }
        .btn-glass:hover { background: #d4af37; color: #000; box-shadow: 0 0 15px rgba(212, 175, 55, 0.5); }
        #file-input { display: none; }
        .color-wrapper {
            width: 40px; height: 40px; border-radius: 50%;
            background: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.2);
            display: flex; align-items: center; justify-content: center;
            backdrop-filter: blur(5px);
        }
        input[type="color"] {
            -webkit-appearance: none; border: none; width: 28px; height: 28px;
            border-radius: 50%; overflow: hidden; cursor: pointer; background: none;
        }
        input[type="color"]::-webkit-color-swatch-wrapper { padding: 0; }
        input[type="color"]::-webkit-color-swatch { border: none; border-radius: 50%; }
        #webcam-preview {
            position: absolute; bottom: 20px; right: 20px; width: 130px; height: auto;
            border-radius: 8px; opacity: 0.6; transform: scaleX(-1);
            border: 1px solid rgba(255,255,255,0.2); pointer-events: auto;
            transition: opacity 0.5s, transform 0.5s;
            background: black;
        }
        .guide-container {
            margin-bottom: 25px; text-align: center;
            transition: opacity 0.5s;
        }
        .guide {
            color: rgba(255,255,255,0.5); font-size: 11px;
            text-transform: uppercase; letter-spacing: 2px; margin-bottom: 5px;
        }
        .hint-h {
            color: #d4af37; font-size: 10px; opacity: 0.8; letter-spacing: 1px; font-style: italic;
        }
        .ui-hidden .controls-wrapper,
        .ui-hidden #webcam-preview,
        .ui-hidden .guide-container {
            opacity: 0; pointer-events: none; transform: translateY(10px);
        }
        #loader {
            position: absolute; inset: 0; z-index: 100; background: #020103;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            transition: opacity 0.8s ease;
        }
        .spinner {
            width: 45px; height: 45px; border: 2px solid rgba(212, 175, 55, 0.2);
            border-top: 2px solid #d4af37; border-radius: 50%; animation: spin 1s linear infinite;
        }
        .loader-text { color: #d4af37; margin-top: 15px; font-size: 12px; letter-spacing: 4px; }
        @keyframes spin { to { transform: rotate(360deg); } }
        @import url('https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700&family=Poppins:wght@300&display=swap');
    </style>
</head>
<body>
    <div id="loader">
        <div class="spinner"></div>
        <div class="loader-text">ƒêANG T·∫¢I PH√âP THU·∫¨T...</div>
    </div>

    <div id="canvas-container"></div>

    <div id="ui-layer">
        <div class="header-content">
            <h1>Happy Birthday<br>Thao Ly</h1>
            <div class="subtext">Magic Moments</div>
        </div>

        <div class="controls-wrapper">
            <label class="btn-glass">
                <span>üì∑ Th√™m ·∫¢nh (1-10)</span>
                <input type="file" id="file-input" multiple accept="image/*">
            </label>
            <div class="color-wrapper">
                <input type="color" id="colorPicker" value="#ffd700" title="ƒê·ªïi m√†u h·∫°t">
            </div>
        </div>

        <div class="guide-container">
            <div class="guide">‚úä N·∫Øm: C√¢y & ·∫¢nh &nbsp;|&nbsp; üñê M·ªü: N·ªï tung &nbsp;|&nbsp; ü´∂ 2 Tay: Tr√°i Tim</div>
            <div class="hint-h">(·∫§n ph√≠m "H" ƒë·ªÉ ·∫©n/hi·ªán giao di·ªán)</div>
        </div>
    </div>

    <video id="webcam" autoplay playsinline style="display:none"></video>
    <canvas id="webcam-preview"></canvas>

    <script type="module">
        import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js';
        import { EffectComposer } from 'https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/postprocessing/EffectComposer.js';
        import { RenderPass } from 'https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/postprocessing/UnrealBloomPass.js';
        import { FilesetResolver, HandLandmarker } from 'https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/+esm';

        // --- C·∫§U H√åNH ---
        const CONFIG = {
            count: 2200,
            treeHeight: 40,
            treeRadius: 15,
            heartScale: 2.0,
            scatterRadius: 40,
            camZ: 70,
            color: new THREE.Color('#ffd700'),
            maxPhotos: 10
        };

        const STATE = {
            mode: 'TREE',
            handDetected: false,
            uiVisible: true
        };

        let scene, camera, renderer, composer, clock;
        let particles, particleGeo, particleMat;
        let photoGroup = new THREE.Group();
        let photoMeshes = [];
        let handLandmarker, videoElement, previewCanvas, previewCtx;

        const targetPositions = { tree: [], scatter: [], heart: [] };

        async function init() {
            clock = new THREE.Clock();
            initThree();
            createParticles();
            scene.add(photoGroup);

            await initMediaPipe();
            setupEvents();

            const loader = document.getElementById('loader');
            loader.style.opacity = 0;
            setTimeout(() => loader.remove(), 800);
            animate();
        }

        function initThree() {
            const container = document.getElementById('canvas-container');
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x050208);
            scene.fog = new THREE.FogExp2(0x050208, 0.002);

            camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = CONFIG.camZ;

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            container.appendChild(renderer.domElement);

            const renderScene = new RenderPass(scene, camera);
            const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
            bloomPass.threshold = 0; bloomPass.strength = 1.2; bloomPass.radius = 0.5;

            composer = new EffectComposer(renderer);
            composer.addPass(renderScene);
            composer.addPass(bloomPass);

            scene.add(new THREE.AmbientLight(0xffffff, 0.8));
        }

        function createParticles() {
            particleGeo = new THREE.BufferGeometry();
            const positions = new Float32Array(CONFIG.count * 3);
            const sizes = new Float32Array(CONFIG.count);

            for (let i = 0; i < CONFIG.count; i++) {
                positions[i * 3] = (Math.random() - 0.5) * 50;
                positions[i * 3 + 1] = (Math.random() - 0.5) * 50;
                positions[i * 3 + 2] = (Math.random() - 0.5) * 50;
                sizes[i] = Math.random();

                // 1. TREE (Spiral)
                let t = Math.pow(Math.random(), 0.5);
                const h = CONFIG.treeHeight;
                const yTree = (t * h) - (h / 2);
                const rTree = CONFIG.treeRadius * (1 - t) * (0.5 + Math.random() * 0.5);
                const angleTree = t * 25 + Math.random() * Math.PI * 2;
                targetPositions.tree.push(Math.cos(angleTree) * rTree, yTree, Math.sin(angleTree) * rTree);

                // 2. SCATTER (Sphere)
                const phi = Math.acos(-1 + (2 * Math.random()));
                const theta = Math.sqrt(CONFIG.count * Math.PI) * phi;
                const rScatter = CONFIG.scatterRadius * (0.6 + Math.random() * 1.2);
                targetPositions.scatter.push(rScatter * Math.cos(theta) * Math.sin(phi), rScatter * Math.sin(theta) * Math.sin(phi), rScatter * Math.cos(phi));

                // 3. HEART (3D Math)
                const tHeart = Math.random() * Math.PI * 2;
                const rFill = Math.pow(Math.random(), 0.4);
                let hx = 16 * Math.pow(Math.sin(tHeart), 3);
                let hy = 13 * Math.cos(tHeart) - 5 * Math.cos(2 * tHeart) - 2 * Math.cos(3 * tHeart) - Math.cos(4 * tHeart);
                let hz = (Math.random() - 0.5) * 8;
                const s = rFill * CONFIG.heartScale * 0.08;
                targetPositions.heart.push(hx * s, (hy * s) + 3, hz * s);
            }

            particleGeo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            particleGeo.setAttribute('size', new THREE.BufferAttribute(sizes, 1));

            const canvas = document.createElement('canvas'); canvas.width = 32; canvas.height = 32;
            const ctx = canvas.getContext('2d');
            const grad = ctx.createRadialGradient(16, 16, 0, 16, 16, 16);
            grad.addColorStop(0, 'rgba(255,255,255,1)');
            grad.addColorStop(1, 'rgba(0,0,0,0)');
            ctx.fillStyle = grad; ctx.fillRect(0, 0, 32, 32);

            particleMat = new THREE.PointsMaterial({
                color: CONFIG.color, size: 0.8, map: new THREE.CanvasTexture(canvas),
                transparent: true, opacity: 0.9, depthWrite: false, blending: THREE.AdditiveBlending
            });
            particles = new THREE.Points(particleGeo, particleMat);
            scene.add(particles);
        }

        // --- X·ª¨ L√ù ·∫¢NH (NOEL V2 LOGIC) ---
        function handleImageUpload(e) {
            const files = e.target.files;
            if (!files.length) return;

            photoMeshes.forEach(m => photoGroup.remove(m.mesh));
            photoMeshes = [];

            const count = Math.min(files.length, CONFIG.maxPhotos);

            Array.from(files).slice(0, count).forEach((file, index) => {
                const reader = new FileReader();
                reader.onload = (ev) => {
                    new THREE.TextureLoader().load(ev.target.result, (tex) => {
                        // prefer encoding flag for color-correct display
                        if ('sRGBEncoding' in THREE) tex.encoding = THREE.sRGBEncoding;
                        createPhotoFrame(tex, index, count);
                    });
                };
                reader.readAsDataURL(file);
            });
        }

        function createPhotoFrame(texture, index, total) {
            const group = new THREE.Group();

            const frameGeo = new THREE.PlaneGeometry(5.5, 6.5);
            const frameMat = new THREE.MeshBasicMaterial({ color: 0xffffff });
            const frame = new THREE.Mesh(frameGeo, frameMat);

            const photoGeo = new THREE.PlaneGeometry(5.0, 5.0);
            const photoMat = new THREE.MeshBasicMaterial({ map: texture });
            const photo = new THREE.Mesh(photoGeo, photoMat);
            photo.position.set(0, 0.4, 0.02);

            group.add(frame);
            group.add(photo);

            const h = CONFIG.treeHeight * 0.7;
            const yStep = h / total;
            const y = (index * yStep) - (h / 2) + 5;

            const angle = index * 2.2;
            const radius = CONFIG.treeRadius * (1 - (index / total)) * 1.3;

            const x = Math.cos(angle) * radius;
            const z = Math.sin(angle) * radius;

            const data = {
                mesh: group,
                posTree: new THREE.Vector3(x, y, z),
                posScatter: new THREE.Vector3(x * 3, y * 3, z * 3),
                angleBase: angle
            };

            group.position.copy(data.posTree);
            group.lookAt(0, y, 0);
            group.rotateY(Math.PI);

            photoGroup.add(group);
            photoMeshes.push(data);
        }

        function updatePhotos(dt, time) {
            if (STATE.mode === 'TREE') {
                photoGroup.rotation.y += 0.005;
            } else if (STATE.mode === 'SCATTER') {
                photoGroup.rotation.y += 0.002;
            }

            photoMeshes.forEach(p => {
                let target, scale;
                if (STATE.mode === 'HEART') {
                    target = p.posTree; scale = 0;
                } else if (STATE.mode === 'SCATTER') {
                    target = p.posScatter; scale = 1.2;
                    p.mesh.rotation.z = Math.sin(time + p.angleBase) * 0.3;
                } else {
                    target = p.posTree; scale = 0.8;
                    p.mesh.rotation.z = THREE.MathUtils.lerp(p.mesh.rotation.z, 0, dt * 2);
                }

                p.mesh.position.lerp(target, dt * 3);
                p.mesh.scale.lerp(new THREE.Vector3(scale, scale, scale), dt * 4);

                if (STATE.mode === 'TREE') {
                    p.mesh.lookAt(camera.position);
                }
            });
        }

        // --- MEDIAPIPE ---
        async function initMediaPipe() {
            videoElement = document.getElementById('webcam');
            previewCanvas = document.getElementById('webcam-preview');
            previewCtx = previewCanvas.getContext('2d');
            previewCanvas.width = 160; previewCanvas.height = 120;

            try {
                const vision = await FilesetResolver.forVisionTasks("https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/wasm");
                // try GPU delegate first, fallback to CPU if fails
                try {
                    handLandmarker = await HandLandmarker.createFromOptions(vision, {
                        baseOptions: { modelAssetPath: `https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task`, delegate: "GPU" },
                        runningMode: "VIDEO", numHands: 2
                    });
                } catch (gpuErr) {
                    console.warn("GPU delegate failed, falling back to CPU:", gpuErr);
                    handLandmarker = await HandLandmarker.createFromOptions(vision, {
                        baseOptions: { modelAssetPath: `https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task` },
                        runningMode: "VIDEO", numHands: 2
                    });
                }
            } catch (err) {
                console.error("MediaPipe init failed:", err);
            }

            if (navigator.mediaDevices?.getUserMedia) {
                try {
                    videoElement.srcObject = await navigator.mediaDevices.getUserMedia({ video: true });
                    videoElement.addEventListener("loadeddata", predictWebcam);
                } catch (e) { console.log("Cam error", e); }
            } else {
                console.warn("getUserMedia not available in this browser.");
            }
        }

        let lastVideoTime = -1;
        async function predictWebcam() {
            if (videoElement.currentTime !== lastVideoTime) {
                lastVideoTime = videoElement.currentTime;
                if (handLandmarker) {
                    try {
                        const res = handLandmarker.detectForVideo(videoElement, performance.now());

                        if (STATE.uiVisible) {
                            // draw mirrored preview (canvas is mirrored with CSS scaleX(-1))
                            previewCtx.save();
                            previewCtx.scale(-1, 1);
                            previewCtx.drawImage(videoElement, -previewCanvas.width, 0, previewCanvas.width, previewCanvas.height);
                            previewCtx.restore();
                        }

                        processGestures(res);
                    } catch (err) {
                        console.warn("handLandmarker.detectForVideo error:", err);
                    }
                }
            }
            requestAnimationFrame(predictWebcam);
        }

        function processGestures(res) {
            if (res && res.landmarks && res.landmarks.length) {
                STATE.handDetected = true;
                if (res.landmarks.length === 2) {
                    const h1 = res.landmarks[0], h2 = res.landmarks[1];
                    const dist = Math.hypot(h1[8].x - h2[8].x, h1[8].y - h2[8].y);
                    const wristDist = Math.hypot(h1[0].x - h2[0].x, h1[0].y - h2[0].y);
                    if (dist < 0.25 || wristDist < 0.35) { STATE.mode = 'HEART'; return; }
                }

                const lm = res.landmarks[0];
                const tips = [8, 12, 16, 20];
                let avg = 0; tips.forEach(i => avg += Math.hypot(lm[i].x - lm[0].x, lm[i].y - lm[0].y));
                avg /= 4;
                STATE.mode = (avg > 0.35) ? 'SCATTER' : 'TREE';
            } else {
                STATE.mode = 'TREE';
            }
        }

        function setupEvents() {
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight); composer.setSize(window.innerWidth, window.innerHeight);
            });

            document.getElementById('colorPicker').addEventListener('input', (e) => {
                CONFIG.color.set(e.target.value); particleMat.color.set(CONFIG.color);
            });
            document.getElementById('file-input').addEventListener('change', handleImageUpload);

            window.addEventListener('keydown', (e) => {
                if (e.key.toLowerCase() === 'h') {
                    STATE.uiVisible = !STATE.uiVisible;
                    const ui = document.getElementById('ui-layer');
                    if (!STATE.uiVisible) ui.classList.add('ui-hidden'); else ui.classList.remove('ui-hidden');
                }
            });
        }

        function animate() {
            requestAnimationFrame(animate);
            const dt = clock.getDelta();
            const time = clock.getElapsedTime();

            if (particles) {
                if (STATE.mode === 'TREE') particles.rotation.y += 0.005;
                else if (STATE.mode === 'HEART') particles.rotation.y = Math.sin(time) * 0.1;
                else particles.rotation.y += 0.002;

                const positions = particles.geometry.attributes.position.array;
                const target = (STATE.mode === 'HEART') ? targetPositions.heart : (STATE.mode === 'SCATTER' ? targetPositions.scatter : targetPositions.tree);

                for (let i = 0; i < CONFIG.count; i++) {
                    const ix = i * 3, iy = i * 3 + 1, iz = i * 3 + 2;
                    let tx = target[ix], ty = target[iy], tz = target[iz];

                    if (STATE.mode === 'HEART') {
                        const beat = 1 + Math.pow(Math.sin(time * 3), 63) * 0.15;
                        tx *= beat; ty = (ty * beat); tz *= beat;
                    }

                    positions[ix] += (tx - positions[ix]) * 0.06;
                    positions[iy] += (ty - positions[iy]) * 0.06;
                    positions[iz] += (tz - positions[iz]) * 0.06;
                }
                particles.geometry.attributes.position.needsUpdate = true;
            }

            updatePhotos(dt, time);
            composer.render();
        }

        init();
    </script>
</body>
</html>
